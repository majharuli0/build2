{"version":3,"file":"barChart-C2ej5wPT.js","sources":["../../src/Components/GraphAndChart/barChart.jsx"],"sourcesContent":["import React, { useMemo, useState, useEffect } from \"react\";\nimport ReactECharts from \"echarts-for-react\";\nimport ls from \"store2\";\nimport { formatTimeToHoursAndMinutes } from \"@/utils/helper\";\nimport { Empty } from \"antd\";\nimport dayjs from \"dayjs\";\n\nexport default function BarChart({\n  data,\n  dataType,\n  color,\n  chartType = \"Day\",\n  toDate,\n  fromDate,\n  xUnit = \"date\",\n  hourLimit = 12,\n  numberLimit = 100,\n  dataUnit = \"\",\n  chartFor = \"\",\n}) {\n  const options = useMemo(() => {\n    if (!data?.length) {\n      return null;\n    }\n\n    const getAllDatesInRange = (start, end) => {\n      const dates = [];\n      const current = new Date(start);\n      const endDate = new Date(end);\n\n      while (current <= endDate) {\n        dates.push(new Date(current).toISOString().split(\"T\")[0]);\n        current.setDate(current.getDate() + 1);\n      }\n      return dates;\n    };\n\n    function generateSleepDistribution(data) {\n      const bucketSize = 10; // Bucket size in minutes (e.g., every 10 minutes)\n      const minBucket = 60; // Minimum bucket range (1 hour)\n      const maxBucket = 720; // Maximum bucket range (12 hours)\n\n      // Generate x-axis labels for time ranges (e.g., \"1 hr\", \"1 hr 10 min\")\n      const xaxis = Array.from(\n        { length: (maxBucket - minBucket) / bucketSize + 1 },\n        (_, i) => {\n          const totalMinutes = minBucket + i * bucketSize;\n          const hours = Math.floor(totalMinutes / 60);\n          const minutes = totalMinutes % 60;\n          return minutes === 0 ? `${hours} hr` : `${hours} hr ${minutes} min`;\n        }\n      );\n\n      // Initialize bucket counts (all set to 0 initially)\n      const bucketCounts = new Array(xaxis.length).fill(0);\n\n      // Count the number of items in each bucket\n      data?.forEach((item) => {\n        const bucketIndex = Math.floor(\n          (item.sleep_total_time - minBucket) / bucketSize\n        );\n        if (bucketIndex >= 0 && bucketIndex < bucketCounts.length) {\n          bucketCounts[bucketIndex]++;\n        }\n      });\n\n      // Calculate the percentage distribution of items in each bucket\n      const totalCounts = bucketCounts.reduce((sum, count) => sum + count, 0);\n      const distribution = bucketCounts.map((count) =>\n        totalCounts > 0 ? ((count / totalCounts) * 100).toFixed(0) : \"0\"\n      );\n\n      // Return x-axis labels and distribution\n      return { xaxis, data: distribution };\n    }\n\n    function generateSleepEfficiencyDistribution(data) {\n      const bucketSize = 10; // Grouping size for sleep efficiency ranges\n      const minBucket = 0; // Minimum sleep efficiency percentage\n      const maxBucket = 100; // Maximum sleep efficiency percentage\n\n      // Generate x-axis labels (e.g., \"10-20\", \"20-30\")\n      const xaxis = Array.from(\n        { length: (maxBucket - minBucket) / bucketSize },\n        (_, i) =>\n          `${minBucket + i * bucketSize}-${minBucket + (i + 1) * bucketSize}`\n      );\n\n      // Initialize bucket counts for each range\n      const bucketCounts = new Array(xaxis.length).fill(0);\n\n      // Count the number of days falling into each bucket\n      data?.forEach((item) => {\n        const bucketIndex = Math.floor(\n          chartFor !== \"deepSleepPercentageDistribution\"\n            ? item?.sleep_efficiency / bucketSize\n            : item?.sleep_quality / bucketSize\n        );\n        if (bucketIndex >= 0 && bucketIndex < bucketCounts.length) {\n          bucketCounts[bucketIndex]++;\n        }\n      });\n\n      // Calculate the total number of days\n      const totalDays = data.length;\n\n      // Calculate the distribution percentages for the y-axis\n      const distribution = bucketCounts.map((count) =>\n        totalDays > 0 ? ((count / totalDays) * 100).toFixed(0) : \"0\"\n      );\n      ls.set(chartFor, { xaxis, data: distribution });\n      // Return the distribution data with x-axis labels and percentages\n      return { xaxis, data: distribution };\n    }\n\n    function generateApneaIndexDistribution(data) {\n      const bucketSize = 5; // Grouping by 5 units for the Apnea Index\n      const minBucket = 0; // Start at 0\n      const maxBucket = 30; // End at 30 (Apnea Index range)\n\n      // Generate x-axis labels for ranges (e.g., \"0-5\", \"5-10\", \"10-15\", ..., \"25-30\")\n      const xaxis = Array.from(\n        { length: maxBucket / bucketSize },\n        (_, i) => `${i * bucketSize}-${(i + 1) * bucketSize}`\n      );\n\n      // Initialize bucket counts for each Apnea Index range\n      const bucketCounts = new Array(xaxis.length).fill(0);\n\n      // Count the number of days falling into each Apnea Index bucket\n      data?.forEach((item) => {\n        const ahiValue = parseFloat(item.ahi);\n        const bucketIndex = Math.floor(ahiValue / bucketSize); // Group by bucket size of 5\n        if (bucketIndex >= 0 && bucketIndex < bucketCounts.length) {\n          bucketCounts[bucketIndex]++;\n        }\n      });\n\n      // Calculate the total number of days\n      const totalDays = data.length;\n\n      // Calculate the distribution percentages for the y-axis\n      const distribution = bucketCounts.map((count) =>\n        totalDays > 0 ? ((count / totalDays) * 100).toFixed(0) : \"0\"\n      );\n\n      // Return the distribution data with x-axis labels and percentages\n      return { xaxis, data: distribution };\n    }\n    function generateFallAsleepDurationDistribution(data) {\n      const bucketSize = 10; // Grouping by 10 minutes\n      const minBucket = 0; // Start at 0 minutes\n      const maxBucket = 120; // End at 120 minutes\n\n      // Generate x-axis labels for ranges (e.g., \"0-10\", \"10-20\", ..., \"110-120\")\n      const xaxis = Array.from(\n        { length: maxBucket / bucketSize },\n        (_, i) => `${i * bucketSize}-${(i + 1) * bucketSize}`\n      );\n\n      // Initialize bucket counts for each Fall Asleep Duration range\n      const bucketCounts = new Array(xaxis.length).fill(0);\n\n      // Count the number of days falling into each Fall Asleep Duration bucket\n      data?.forEach((item) => {\n        const duration = item.totalFallAsleepDuration;\n        const bucketIndex = Math.floor(duration / bucketSize); // Group by bucket size of 10\n        if (bucketIndex >= 0 && bucketIndex < bucketCounts.length) {\n          bucketCounts[bucketIndex]++;\n        }\n      });\n\n      // Calculate the total number of days\n      const totalDays = data.length;\n\n      // Calculate the distribution percentages for the y-axis\n      const distribution = bucketCounts.map((count) =>\n        totalDays > 0 ? ((count / totalDays) * 100).toFixed(0) : \"0\"\n      );\n\n      // Return the distribution data with x-axis labels and percentages\n      return { xaxis, data: distribution };\n    }\n\n    // function generateBreathRateDistribution(data) {\n    //   const minBreathRate = 6; // Minimum breath rate\n    //   const maxBreathRate = 36; // Maximum breath rate\n\n    //   // Initialize counts for each breath rate\n    //   const breathRateCounts = new Array(\n    //     maxBreathRate - minBreathRate + 1\n    //   ).fill(0);\n\n    //   // Count occurrences of each avg breath rate\n    //   data?.forEach((item) => {\n    //     const avgRate = Math.round(item.avg); // Round avg rate to nearest integer\n    //     if (avgRate >= minBreathRate && avgRate <= maxBreathRate) {\n    //       const index = avgRate - minBreathRate;\n    //       breathRateCounts[index]++;\n    //     }\n    //   });\n\n    //   // Calculate total entries\n    //   const totalEntries = data.length;\n\n    //   // Calculate the percentage for each breath rate\n    //   const distribution = breathRateCounts.map((count) =>\n    //     totalEntries > 0 ? ((count / totalEntries) * 100).toFixed(0) : \"0\"\n    //   );\n\n    //   // Create x-axis labels (6 to 36)\n    //   const xaxis = Array.from(\n    //     { length: maxBreathRate - minBreathRate + 1 },\n    //     (_, i) => (minBreathRate + i).toString()\n    //   );\n\n    //   return { xaxis, data: distribution };\n    // }\n    function calculateBreathRateDistribution(data) {\n      // Breath rate range [6 to 36]\n      const breathRateRange = Array.from({ length: 31 }, (_, i) => i + 6); // [6, 7, ..., 36]\n\n      const result = {\n        xaxis: breathRateRange.map((rate) => rate.toString()), // X-axis values for 6-36\n        data: Array(31).fill(0), // Initialize with zeros for each breath rate in the range (6-36)\n      };\n\n      let totalCounts = Array(31).fill(0); // Sum of counts for each rate (6-36) across all days\n\n      // Iterate over each day's data\n      data.forEach((day) => {\n        // Filter out invalid breath rates (-1 and 0), and convert the valid data to numbers\n        const validData = day.data_list\n          .filter((value) => value !== \"-1\" && value !== \"0\")\n          .map(Number);\n\n        // Create an array to hold counts for each rate (6-36) for this day\n        let dayCounts = Array(31).fill(0);\n\n        validData.forEach((rate) => {\n          if (rate >= 6 && rate <= 36) {\n            const index = rate - 6; // Map rate to index (6 -> index 0, 7 -> index 1, ..., 36 -> index 30)\n            dayCounts[index]++;\n          }\n        });\n\n        // Sum up the counts for the current day for each rate\n        dayCounts.forEach((count, index) => {\n          totalCounts[index] += count;\n        });\n      });\n\n      // Identify the valid range (first and last non-zero index)\n      const validIndices = totalCounts\n        .map((count, index) => (count > 0 ? index : null))\n        .filter((index) => index !== null);\n\n      if (validIndices.length === 0) {\n        return result; // If no valid data, return result with all zeros\n      }\n\n      const validStart = Math.max(validIndices[0] - 1, 0);\n      const validEnd = Math.min(validIndices[validIndices.length - 1] + 1, 30);\n\n      // Calculate the total count within the valid range\n      const validTotal = totalCounts\n        .slice(validStart, validEnd + 1)\n        .reduce((sum, count) => sum + count, 0);\n\n      // Calculate distributed percentages within the valid range\n      result.data = totalCounts.map((count, index) => {\n        if (index >= validStart && index <= validEnd && validTotal > 0) {\n          return ((count / validTotal) * 100).toFixed(2);\n        }\n        return \"0.00\";\n      });\n\n      // Return the result in the required format\n      return result;\n    }\n\n    const heartRateRanges = [\n      \"45-50\",\n      \"50-55\",\n      \"55-60\",\n      \"60-65\",\n      \"65-70\",\n      \"70-75\",\n      \"75-80\",\n      \"80-85\",\n      \"85-90\",\n      \"90-95\",\n      \"95-100\",\n      \"100-105\",\n      \"105-110\",\n      \"110-115\",\n      \"115-120\",\n    ];\n    const calculateHeartRateDistribution = (data) => {\n      // Initialize a count array for each range\n      const rangeCounts = new Array(heartRateRanges.length).fill(0);\n      // Loop through each day's data\n      data?.forEach((day) => {\n        day.data_list.forEach((value) => {\n          if (value > 0) {\n            // Consider only valid values (excluding 0 or negative values)\n            // Find which range this value falls into and increment the corresponding count\n            for (let i = 0; i < heartRateRanges.length; i++) {\n              const [min, max] = heartRateRanges[i].split(\"-\").map(Number);\n              if (value >= min && value < max) {\n                rangeCounts[i] += 1;\n                break; // Once the correct range is found, break out of the loop\n              }\n            }\n          }\n        });\n      });\n\n      // Calculate total valid values across all days\n      const totalValidValues = data?.reduce(\n        (sum, day) => sum + day.data_list.filter((value) => value > 0).length,\n        0\n      );\n\n      // Calculate the percentage for each range\n      const distribution = rangeCounts.map((count) =>\n        ((count / totalValidValues) * 100).toFixed(0)\n      );\n\n      return {\n        xaxis: heartRateRanges,\n        data: distribution,\n      };\n    };\n    const getChartData = () => {\n      if (xUnit === \"number\") {\n        if (chartFor === \"apneaIndexDistribution\") {\n          const { xaxis, data: distribution } =\n            generateApneaIndexDistribution(data);\n\n          return xaxis.map((label, index) => ({\n            number: label,\n            value: distribution[index],\n          }));\n        } else if (chartFor === \"heartRateDistribution\") {\n          const { xaxis, data: distribution } =\n            calculateHeartRateDistribution(data);\n\n          // Combine xaxis and distribution into chart data\n          return xaxis.map((label, index) => ({\n            number: label,\n            value: distribution[index],\n          }));\n        } else if (chartFor === \"breathRateDistribution\") {\n          const { xaxis, data: distribution } =\n            calculateBreathRateDistribution(data);\n\n          // Combine xaxis and distribution into chart data\n          return xaxis.map((label, index) => ({\n            number: label,\n            value: distribution[index],\n          }));\n        }\n      }\n      if (xUnit === \"hour\") {\n        // Ensure data is valid\n        if (data && data.length > 0 && chartFor === \"durationDistribution\") {\n          const { xaxis, data: distribution } = generateSleepDistribution(data);\n\n          // Combine xaxis and distribution into chart data\n          return xaxis.map((label, index) => ({\n            hour: label,\n            percentage: parseInt(label, 10), // Use calculated percentage\n            value: distribution[index], // Convert xaxis label back to a numeric value for display\n          }));\n        } else if (\n          data &&\n          data.length > 0 &&\n          chartFor === \"fallAsleepDurationDistribution\"\n        ) {\n          const { xaxis, data: distribution } =\n            generateFallAsleepDurationDistribution(data);\n\n          // Combine xaxis and distribution into chart data\n          return xaxis.map((label, index) => ({\n            hour: label,\n            percentage: parseInt(label, 10), // Use calculated percentage\n            value: distribution[index], // Convert xaxis label back to a numeric value for display\n          }));\n        } else {\n          // Generate empty dataset if no data is present\n          return Array.from({ length: hourLimit }, (_, i) => ({\n            hour: i,\n            value: 0,\n            percentage: 0,\n          }));\n        }\n      } else if (xUnit === \"percentage\") {\n        if (\n          chartFor === \"efficiencyDistribution\" ||\n          chartFor === \"deepSleepPercentageDistribution\"\n        ) {\n          const { xaxis, data: distribution } =\n            generateSleepEfficiencyDistribution(data);\n\n          // Combine xaxis and distribution into chart data\n          return xaxis.map((label, index) => ({\n            percentage: label,\n            value: distribution[index], // Convert xaxis label back to a numeric value for display\n          }));\n        } else {\n          // Generate array of percentages from 0 to 100 (by 10s)\n          const percentages = Array.from({ length: 11 }, (_, i) => i * 10);\n          // Create a map of existing data\n          const dataMap = new Map(\n            data.map((item) => [\n              Math.floor(item.sleep_efficiency / 10) * 10, // Round to nearest 10\n              {\n                value: item.sleep_efficiency,\n                date: item.date,\n              },\n            ])\n          );\n\n          // Create complete dataset with 0 for missing percentages\n          return percentages.map((percentage) => ({\n            percentage,\n            value: dataMap.get(percentage)?.value || 0,\n            date: dataMap.get(percentage)?.date || null,\n          }));\n        }\n      } else {\n        // Existing date-based logic\n        const getAllDatesInRange = (start, end) => {\n          const dates = [];\n          const current = new Date(start);\n          const endDate = new Date(end);\n\n          while (current <= endDate) {\n            dates.push(new Date(current).toISOString().split(\"T\")[0]);\n            current.setDate(current.getDate() + 1);\n          }\n          return dates;\n        };\n\n        const allDates = getAllDatesInRange(fromDate, toDate);\n        const dataMap = new Map(\n          data?.map((item) => [\n            item?.date?.split(\"T\")[0] ||\n              (chartFor === \"roomInOut\" ||\n              chartFor === \"walkingStepsStatistix\" ||\n              chartFor === \"walkingSpeedStatistic\"\n                ? dayjs(item.datestr).subtract(1, \"day\").format(\"YYYY-MM-DD\")\n                : item?.datestr),\n            item.ratio ||\n              (chartFor === \"walkingSpeedStatistic\" &&\n                item?.user_activity?.speed) ||\n              item.bed_exit_duration ||\n              item.value ||\n              item.sleep_time ||\n              item.ahi ||\n              (chartFor === \"walkingStepsStatistix\" &&\n                item?.user_activity?.step_number) ||\n              item.anomalyHeartRate ||\n              item.sleep_efficiency ||\n              (item.leave_bed_count && chartFor === \"numberOfBedExitTime\"\n                ? item.leave_bed_count\n                : null) ||\n              (item.sleep_quality &&\n              chartFor !== \"numberOfBedExitTime\" &&\n              chartFor !== \"roomInOut\" &&\n              chartFor === \"deepSleepPercentageStatistic\"\n                ? item.sleep_quality\n                : null) ||\n              (item?.user_activity?.entry_room_count && chartFor === \"roomInOut\"\n                ? item?.user_activity.entry_room_count\n                : null) ||\n              (chartFor === \"sleedDurationStatistic\" &&\n                item.sleep_total_time) ||\n              item.totalFallAsleepDuration ||\n              \"--\",\n          ])\n        );\n\n        return allDates.map((date) => ({\n          date,\n          value: dataMap.get(date) || 0,\n        }));\n      }\n    };\n\n    const chartData = getChartData();\n\n    const formatValue = (value, type = \"axis\") => {\n      if (xUnit === \"percentage\" || dataType === \"percentage\") {\n        return `${value}%`;\n      }\n      if (dataType === \"duration\") {\n        const hours = Math.floor(value / 60);\n        const minutes = value % 60;\n        return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;\n      }\n\n      return value;\n    };\n\n    const formatXAxis = (value) => {\n      if (xUnit === \"number\") {\n        return value?.toString();\n      }\n      if (xUnit === \"hour\") {\n        return `${value}`;\n      }\n      if (xUnit === \"percentage\") {\n        return `${value}%`;\n      }\n      if (chartType === \"Week\") {\n        const weekNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n        const dateObj = new Date(value);\n        return weekNames[dateObj.getDay()];\n      }\n      const dateObj = new Date(value);\n      return dateObj\n        .toLocaleDateString(\"en-US\", {\n          month: \"2-digit\",\n          day: \"2-digit\",\n        })\n        .replace(\"/\", \"-\");\n    };\n\n    return {\n      xAxis: {\n        type: \"category\",\n        data: chartData.map((item) =>\n          xUnit === \"hour\"\n            ? formatXAxis(item.hour)\n            : xUnit === \"percentage\"\n            ? formatXAxis(item.percentage)\n            : xUnit === \"number\"\n            ? formatXAxis(item.number)\n            : formatXAxis(item.date)\n        ),\n      },\n\n      grid: {\n        top: \"5%\",\n        left: \"8%\",\n        bottom: \"5%\",\n        right: \"2%\",\n      },\n      yAxis: {\n        type: \"value\",\n        axisLabel: {\n          formatter: formatValue,\n        },\n        max:\n          xUnit === \"percentage\" || dataType === \"percentage\" ? 100 : undefined,\n      },\n      series: [\n        {\n          data: chartData.map((item) => item.value),\n          type: \"bar\",\n          barWidth: 10,\n          itemStyle: {\n            color: color || \"#000\",\n            borderRadius: [50, 50, 0, 0],\n          },\n        },\n      ],\n      tooltip: {\n        trigger: \"axis\",\n        formatter: (params) => {\n          if (xUnit === \"number\") {\n            if (chartFor !== \"apneaIndexDistribution\") {\n              const item = chartData[params[0].dataIndex];\n              return `<div style=\"margin-top: 4px\">\n              <span >${item.value}%</span>\n              <br>\n              <span style=\"font-weight: bold\">${item.number} BPM</span>\n              </div>`;\n            } else {\n              const item = chartData[params[0].dataIndex];\n              return `<div style=\"margin-top: 4px\">\n              <span style=\"font-weight: bold\">${item.value}%</span>\n              <br>\n              <span style=\"font-weight: normal\">${item.number}</span>\n              </div>`;\n            }\n          } else if (xUnit === \"hour\") {\n            const item = chartData[params[0].dataIndex];\n            return `<div style=\"margin-top: 4px\">\n                    ${item.value ? `<span>${item.value}%</span>` : \"--\"}\n                    <br>\n                    <span style=\"font-weight: bold\">${item.hour}</span>\n                    </div>`;\n          } else if (xUnit === \"percentage\") {\n            const item = chartData[params[0].dataIndex];\n            if (item.date) {\n              const fullDate = new Date(item.date)\n                .toLocaleDateString(\"en-US\", {\n                  year: \"numeric\",\n                  month: \"2-digit\",\n                  day: \"2-digit\",\n                })\n                .replace(/\\//g, \"-\");\n              return `<div style=\"font-weight: bold\">${item.value}%</div>\n                     <div style=\"margin-top: 4px\">${fullDate}</div>`;\n            }\n            return `<div style=\"font-weight: bold\"> ${item.value}% <br/> <span style=\"font-weight: normal\">${item.percentage}%</span></div>`;\n          }\n\n          const date = chartData[params[0].dataIndex].date;\n          const fullDate = new Date(date)\n            .toLocaleDateString(\"en-US\", {\n              year: \"numeric\",\n              month: \"2-digit\",\n              day: \"2-digit\",\n            })\n            .replace(/\\//g, \"-\");\n\n          return `<div style=\"font-weight: bold\">${fullDate}</div>\n                  <div style=\"margin-top: 4px\">${formatValue(\n                    params[0].value\n                  )}${dataUnit}</div>`;\n        },\n      },\n    };\n  }, [\n    data,\n    dataType,\n    color,\n    chartType,\n    fromDate,\n    toDate,\n    xUnit,\n    hourLimit,\n    numberLimit,\n  ]);\n\n  if (!data?.length || !options) {\n    return (\n      <div className=\"w-full h-full flex items-center justify-center\">\n        {\" \"}\n        <Empty description=\"No data available to show\" />\n      </div>\n    );\n  }\n\n  return <ReactECharts option={options} style={{ height: \"350px\" }} />;\n}\n"],"names":["BarChart","data","dataType","color","chartType","toDate","fromDate","xUnit","hourLimit","numberLimit","dataUnit","chartFor","options","useMemo","generateSleepDistribution","xaxis","_","i","totalMinutes","hours","minutes","bucketCounts","item","bucketIndex","totalCounts","sum","count","distribution","generateSleepEfficiencyDistribution","totalDays","ls","generateApneaIndexDistribution","ahiValue","generateFallAsleepDurationDistribution","duration","calculateBreathRateDistribution","result","rate","day","validData","value","dayCounts","index","validIndices","validStart","validEnd","validTotal","heartRateRanges","calculateHeartRateDistribution","rangeCounts","min","max","totalValidValues","chartData","label","percentages","dataMap","percentage","_a","_b","allDates","start","end","dates","current","endDate","dayjs","_c","_d","date","formatValue","type","formatXAxis","weekNames","dateObj","params","fullDate","jsxs","jsx","Empty","ReactECharts"],"mappings":"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"}